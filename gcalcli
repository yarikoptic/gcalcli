#!/usr/bin/python

# ** The MIT License **
#
# Copyright (c) 2007 Eric Davis (aka Insanum)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


#
# Home: http://code.google.com/p/gcalcli
#
# TODO:
#  - import meeting.ics Outlook events ("gcalcli import <file|stdin>")
#  - calendar selection (perform operation against a single calendar)
#  - add (non-quick) events with ability to set reminders, repeat, guests, etc
#  - configurable 'remind' reminders (i.e. 30 mins before event every 5 mins)
#  - daemon mode for 'remind' reminders (working from cached data)
#  - more agenda output formats
#  - cache calendar information (serialize calendar info to file)
#  - rc file support for default colors, login info, etc
#  - locales
#

__username__ = '<username>@gmail.com'
__password__ = '<password>'

__program__ = 'gcalcli'
__version__ = 'v1.1'
__author__  = 'Insanum'

import inspect

import sys, os, re, urllib, getopt, shlex
from gdata.calendar.service import *
from datetime import *
from dateutil.tz import *
from dateutil.parser import *


def Usage():
    sys.stdout.write('''
Usage:

gcalcli [options] command [command args]

 Options:

  --help                    this usage text

  --user <username>         google username

  --pw <password>           password

  --cals=[all,              calendars to work with (default is all calendars)
          default,          - default (your default main calendar)
          owner,            - owner (your owned calendars)
          read,             - read (read only calendars)
          freebusy,         - freebusy (only free/busy info visible)
          contributor]      - contributor (non-owner but able to edit)

  --details                 show all event details (i.e. length, location,
                            reminders, contents)

  --nc                      don't use color sequences

 Commands:

  list                      list all calendars

  search <text>             search for events
                            - only matches whole words

  agenda [start] [end]      get an agenda for a time period
                            - start time default is 12am today
                            - end time default is 5 days from start
                            - example time strings:
                               '9/24/2007'
                               'Sep 24 2007 3:30pm'
                               '2007-09-24T15:30'
                               '2007-09-24T15:30-8:00'
                               '20070924T15'
                               '8am'

  quick <text>              quick add an event to default calendar
                            - example:
                               'Dinner with Eric 7pm tomorrow'
                               '5pm 10/31 Trick or Treat'

  remind <mins> <command>   execute command if event occurs within <mins>
                            minutes time ('%s' in <command> is replaced with
                            event start time and title text)
                            - <minutes> default is 10
                            - default command:
                               'gxmessage -display :0 -center \\
                                          -title "Ding, Ding, Ding!" %s'

''')
    sys.exit(1)


class CLR:

    useColor = True

    def __str__(self):
        if self.useColor: return self.color
        else: return ""

class CLR_NRM(CLR):   color = "[0m"
class CLR_BLK(CLR):   color = "[0;30m"
class CLR_BRBLK(CLR): color = "[30;1m"
class CLR_RED(CLR):   color = "[0;31m"
class CLR_BRRED(CLR): color = "[31;1m"
class CLR_GRN(CLR):   color = "[0;32m"
class CLR_BRGRN(CLR): color = "[32;1m"
class CLR_YLW(CLR):   color = "[0;33m"
class CLR_BRYLW(CLR): color = "[33;1m"
class CLR_BLU(CLR):   color = "[0;34m"
class CLR_BRBLU(CLR): color = "[34;1m"
class CLR_MAG(CLR):   color = "[0;35m"
class CLR_BRMAG(CLR): color = "[35;1m"
class CLR_CYN(CLR):   color = "[0;36m"
class CLR_BRCYN(CLR): color = "[36;1m"
class CLR_WHT(CLR):   color = "[0;37m"
class CLR_BRWHT(CLR): color = "[37;1m"

class CAL_OWN_CLR(CLR_CYN): pass
class CAL_READ_CLR(CLR_MAG): pass
class CAL_DEFAULT_CLR(CLR_NRM): pass


def PrintErrMsg(msg):
    if CLR.useColor:
        sys.stdout.write(str(CLR_BRRED()))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


def PrintMsg(color, msg):
    if CLR.useColor:
        sys.stdout.write(str(color))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


class GoogleCalendar:

    gcal         = None
    cals         = None
    now          = datetime.now(tzlocal())
    feedPrefix   = 'http://www.google.com/calendar/feeds/'
    agendaLength = 5
    username     = ''
    password     = ''
    access       = ''
    details      = False
    command      = 'gxmessage -display :0 -center -title "Ding, Ding, Ding!" %s'

    ACCESS_ALL      = 'all'      # non-google access level
    ACCESS_DEFAULT  = 'default'  # non-google access level
    ACCESS_NONE     = 'none'
    ACCESS_READ     = 'read'
    ACCESS_FREEBUSY = 'freebusy'
    ACCESS_CONTRIB  = 'contributor'
    ACCESS_OWNER    = 'owner'


    def _CalendarAccessCmp(self, x, y):

        order = { self.ACCESS_OWNER:1,
                  self.ACCESS_CONTRIB:2,
                  self.ACCESS_READ:3,
                  self.ACCESS_FREEBUSY:4,
                  self.ACCESS_NONE:5 }

        return cmp(order[x.access_level.value], order[y.access_level.value])


    def __init__(self, username, password, access, details):

        self.gcal     = CalendarService()
        self.username = username
        self.password = password
        self.access   = access
        self.details  = details

        # authenticate and login to google calendar
        try:
            self.gcal.ClientLogin(
                            username=self.username,
                            password=self.password,
                            service='cl',
                            source=__author__+'-'+__program__+'-'+__version__)
        except:
            PrintErrMsg("Error: Failed to authenticate with Google Calendar!\n")
            sys.exit(1)

        # get the list of calendars
        self.cals = self.gcal.GetAllCalendarsFeed()

        self.cals.entry.sort(self._CalendarAccessCmp)

        for cal in self.cals.entry:
            cal.gcalcli_altLink = cal.GetAlternateLink().href
            match = re.match('^' + self.feedPrefix + '(.*?)/(.*?)/(.*)$',
                             cal.gcalcli_altLink)
            cal.gcalcli_username    = urllib.unquote(match.group(1))
            cal.gcalcli_visibility  = urllib.unquote(match.group(2))
            cal.gcalcli_projection  = urllib.unquote(match.group(3))


    def _CalendarWithinAccess(self, cal):

        if (self.access == self.ACCESS_ALL):

            return True

        elif ((self.access == self.ACCESS_DEFAULT) and
              (cal.gcalcli_username != self.username)):

            return False

        elif (self.access != cal.access_level.value):

            return False

        return True


    def _CalendarColor(self, cal):

        if (cal == None):
            return CAL_DEFAULT_CLR()

        if (cal.access_level.value == self.ACCESS_OWNER):
            clr = CAL_OWN_CLR()
        elif (cal.access_level.value == self.ACCESS_READ):
            clr = CAL_READ_CLR()
        else:
            clr = CAL_DEFAULT_CLR()

        return clr


    def _PrintEvents(self, defaultDatetime, eventList):

        if (len(eventList) == 0):
            PrintMsg(CLR_YLW(), "\nNo Events Found...\n")
            return

        eventList.sort(lambda x, y:
                       cmp(x.when[0].start_time, y.when[0].start_time))

        timeFormat = '%l:%M%P'
        dayFormat = '\n%a %b %d' # 10 chars for day
        indent = '          ' # 10 spaces
        detailsIndent = '                   '    # 19 spaces
        day = ''

        for event in eventList:
            startDayTime = parse(event.when[0].start_time,
                                 default=defaultDatetime).astimezone(tzlocal())
            tmpDayStr  = startDayTime.strftime(dayFormat)
            tmpTimeStr = startDayTime.strftime(timeFormat)
            prefix = indent
            if (tmpDayStr != day): day = prefix = tmpDayStr
            PrintMsg(CLR_GRN(), prefix)
            PrintMsg(self._CalendarColor(event.gcalcli_cal),
                     '  %-7s  %s\n' % (tmpTimeStr, event.title.text))

            if self.details:

                clr = CLR_NRM()

                if event.where[0].value_string:
                    str = "%s  Location: %s\n" % (detailsIndent,
                                                 event.where[0].value_string)
                    PrintMsg(clr, str)

                if event.when[0].end_time:
                    endDayTime = parse(event.when[0].end_time,
                                  default=defaultDatetime).astimezone(tzlocal())
                    diffDayTime = (endDayTime - startDayTime)
                    str = "%s  Length: %s\n" % (detailsIndent, diffDayTime)
                    PrintMsg(clr, str)

                # XXX Why does accessing event.when[0].reminder[0] fail?
                for rem in event.when[0].reminder:
                    remStr = ''
                    if rem.days:
                        remStr += "%s Days" % (rem.days)
                    if rem.hours:
                        if (remStr != ''):
                            remStr += ' '
                        remStr += "%s Hours" % (rem.hours)
                    if rem.minutes:
                        if (remStr != ''):
                            remStr += ' '
                        remStr += "%s Minutes" % (rem.minutes)
                    str = "%s  Reminder: %s\n" % (detailsIndent, remStr)
                    PrintMsg(clr, str)

                if event.content.text:
                    str = "%s  Content: %s\n" % (detailsIndent,
                                                event.content.text)
                    PrintMsg(clr, str)


    def _GetAllEvents(self, cal, feed):

        eventList = []

        while 1:
            next = feed.GetNextLink()

            for event in feed.entry:
                event.gcalcli_cal = cal
                eventList.append(event)

            if not next:
                break

            feed = self.gcal.GetCalendarEventFeed(next.href)

        return eventList


    def ListAllCalendars(self):

        accessLen = 0

        for cal in self.cals.entry:
            length = len(cal.access_level.value)
            if (length > accessLen): accessLen = length

        if (accessLen < len('Access')): accessLen = len('Access')

        format = ' %02s  %0' + str(accessLen) + 's  %s\n'

        PrintMsg(CLR_BRYLW(), "\n" + format % ('ID', 'Access', 'Title'))
        PrintMsg(CLR_BRYLW(), format % ('--', '------', '-----'))

        for i, cal in zip(xrange(len(self.cals.entry)), self.cals.entry):
            PrintMsg(self._CalendarColor(cal),
                     format % (i, cal.access_level.value, cal.title.text))


    def TextQuery(self, searchText=''):

        PrintMsg(CLR_BRYLW(), "\nCurrent Time: %s\n" % (self.now.ctime()))

        # the empty string would get *ALL* events...
        if (searchText == ''):
            return

        PrintMsg(CLR_BRWHT(),
                 '\nSearching calendar events for: "%s"\n' % (searchText))

        eventList = []

        for cal in self.cals.entry:

            if not self._CalendarWithinAccess(cal):
                continue

            query = CalendarEventQuery(cal.gcalcli_username,
                                       cal.gcalcli_visibility,
                                       cal.gcalcli_projection,
                                       searchText)
            query.singleevents = 'true'
            # we sort later after getting events from all calendars
            #query.orderby = 'starttime'
            #query.sortorder = 'ascending'
            feed = self.gcal.CalendarQuery(query)

            eventList.extend(self._GetAllEvents(cal, feed))

        self._PrintEvents(self.now, eventList)


    def DateQuery(self, startText='', endText=''):

        PrintMsg(CLR_BRYLW(), "\nCurrent Time: %s\n" % (self.now.ctime()))

        # convert now to midnight this morning and use for default
        now = self.now.replace(hour=0, minute=0, second=0, microsecond=0)

        if (startText == ''):
            start = now
        else:
            try:
                start = parse(startText, default=now)
            except:
                PrintErrMsg('\nError: failed to parse start time\n')
                return

        if (endText == ''):
            end = (start + timedelta(days=self.agendaLength))
        else:
            try:
                end = parse(endText, default=now)
            except:
                PrintErrMsg('\nError: failed to parse end time\n')
                return

        PrintMsg(CLR_BRWHT(),
                 '\nAgenda for [ %s <-> %s ]\n' % (start.ctime(), end.ctime()))

        eventList = []

        for cal in self.cals.entry:

            if not self._CalendarWithinAccess(cal):
                continue

            # see http://code.google.com/apis/calendar/reference.html#Parameters
            query = CalendarEventQuery(cal.gcalcli_username,
                                       cal.gcalcli_visibility,
                                       cal.gcalcli_projection)
            query.start_min = start.isoformat()
            query.start_max = end.isoformat()
            query.singleevents = 'true'
            # we sort later after getting events from all calendars
            #query.orderby = 'starttime'
            #query.sortorder = 'ascending'
            feed = self.gcal.CalendarQuery(query)

            eventList.extend(self._GetAllEvents(cal, feed))

        self._PrintEvents(now, eventList)


    def QuickAdd(self, eventText):

        if (eventText == ''):
            return

        quickEvent = gdata.calendar.CalendarEventEntry()
        quickEvent.content = atom.Content(text=eventText)
        quickEvent.quick_add = gdata.calendar.QuickAdd(value='true')

        self.gcal.InsertEvent(quickEvent,
                              '/calendar/feeds/default/private/full')


    def Remind(self, minutes=10, command=None):

        # default calendar only for now...

        if (command == None):
            command = self.command

        # perform a date query for now + minutes + slip
        start = self.now
        end   = (start + timedelta(minutes=(minutes + 5)))

        # see http://code.google.com/apis/calendar/reference.html#Parameters
        query = CalendarEventQuery(self.username, 'private', 'full')
        query.start_min = start.isoformat()
        query.start_max = end.isoformat()
        query.singleevents = 'true'
        query.orderby = 'starttime'
        query.sortorder = 'ascending'
        feed = self.gcal.CalendarQuery(query)

        eventList = self._GetAllEvents(None, feed)

        message = ''

        for event in eventList:
            tmpDayTime = parse(event.when[0].start_time,
                               default=self.now).astimezone(tzlocal())

            # skip this event if it already started
            # XXX maybe add a 2+ minute grace period here...
            if (tmpDayTime < self.now):
                continue

            tmpTimeStr = tmpDayTime.strftime('%l:%M%P')
            message += '%s  %s\n' % (tmpTimeStr, event.title.text)

        if (message == ''):
            return

        message = "Google Calendar Reminder:\n" + message

        cmd = shlex.split(command)

        for i, a in zip(xrange(len(cmd)), cmd):
            if (a == '%s'):
                cmd[i] = message

        pid = os.fork()
        if not pid:
            os.execvp(cmd[0], cmd)


def DoooooItHippieMonster():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "",
                                   ["user=",
                                    "pw=",
                                    "cals=",
                                    "details",
                                    "nc"])
    except getopt.error, msg:
        Usage()

    usr     = __username__
    pwd     = __password__
    details = False
    access  = 'all'

    # Process options
    for opt, arg in opts:
        if (opt == "--help"): Usage()
        elif (opt == "--user"): usr = arg
        elif (opt == "--pw"): pwd = arg
        elif (opt == "--cals"): access = arg
        elif (opt == "--details"): details = True
        elif (opt == "--nc"): CLR.useColor = False

    if ((usr == '') or (pwd == '')):
        PrintErrMsg('\nError: must specify username and password\n')
        Usage()

    if (len(args) == 0):
        PrintErrMsg('\nError: no command\n')
        Usage()

    if (args[0] == 'list'):
        GoogleCalendar(usr, pwd, access, details).ListAllCalendars()

    elif (args[0] == 'search'):
        if (len(args) != 2):
            PrintErrMsg('\nError: invalid search string\n')
            Usage()
        GoogleCalendar(usr, pwd, access, details).TextQuery(args[1])

    elif (args[0] == 'agenda'):
        if (len(args) == 3):   # start and end
            GoogleCalendar(usr, pwd, access, details).DateQuery(args[1],
                                                                args[2])
        elif (len(args) == 2): # start
            GoogleCalendar(usr, pwd, access, details).DateQuery(args[1])
        elif (len(args) == 1): # defaults
            GoogleCalendar(usr, pwd, access, details).DateQuery()
        else:
            PrintErrMsg('\nError: invalid agenda arguments\n')
            Usage()

    elif (args[0] == 'quick'):
        if (len(args) != 2):
            PrintErrMsg('\nError: invalid event text\n')
            Usage()
        GoogleCalendar(usr, pwd, access, details).QuickAdd(args[1])
        return

    elif (args[0] == 'remind'):
        if (len(args) == 3):   # minutes and command
            GoogleCalendar(usr, pwd, access, details).Remind(int(args[1]),
                                                                 args[2])
        elif (len(args) == 2): # minutes
            GoogleCalendar(usr, pwd, access, details).Remind(int(args[1]))
        elif (len(args) == 1): # defaults
            GoogleCalendar(usr, pwd, access, details).Remind()
        else:
            PrintErrMsg('\nError: invalid remind arguments\n')
            Usage()
        return

    else:
        PrintErrMsg('\nError: unknown command\n')
        Usage()

    sys.stdout.write('\n')


if __name__ == '__main__':
    DoooooItHippieMonster()

